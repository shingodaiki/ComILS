// Copyright (c) 2014 Daniel Grunwald
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of this
// software and associated documentation files (the "Software"), to deal in the Software
// without restriction, including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
// to whom the Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection.Metadata" #>
<#@ import namespace="System.Reflection.Emit" #>
<#@ output extension=".cs" #>
using System;
using System.Collections.Generic;
using System.Reflection.Metadata;
<#
	var operandTypes = Enumerable.Repeat((OperandType)0xff, 0x11f).ToArray();
	var operandNames = new string[0x11f];
#>
namespace ICSharpCode.Decompiler.IL
{
	/// <summary>Describes the operand type of Microsoft intermediate language (MSIL) instruction.</summary>
	public enum OperandType
	{
		/// <summary>The operand is a 32-bit integer branch target.</summary>
		BrTarget,
		/// <summary>The operand is a 32-bit metadata token.</summary>
		Field,
		/// <summary>The operand is a 32-bit integer.</summary>
		I,
		/// <summary>The operand is a 64-bit integer.</summary>
		I8,
		/// <summary>The operand is a 32-bit metadata token.</summary>
		Method,
		/// <summary>No operand.</summary>
		None,
		/// <summary>The operand is reserved and should not be used.</summary>
		[Obsolete("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
		Phi,
		/// <summary>The operand is a 64-bit IEEE floating point number.</summary>
		R,
		/// <summary>The operand is a 32-bit metadata signature token.</summary>
		Sig = 9,
		/// <summary>The operand is a 32-bit metadata string token.</summary>
		String,
		/// <summary>The operand is the 32-bit integer argument to a switch instruction.</summary>
		Switch,
		/// <summary>The operand is a <see langword="FieldRef" />, <see langword="MethodRef" />, or <see langword="TypeRef" /> token.</summary>
		Tok,
		/// <summary>The operand is a 32-bit metadata token.</summary>
		Type,
		/// <summary>The operand is 16-bit integer containing the ordinal of a local variable or an argument.</summary>
		Variable,
		/// <summary>The operand is an 8-bit integer branch target.</summary>
		ShortBrTarget,
		/// <summary>The operand is an 8-bit integer.</summary>
		ShortI,
		/// <summary>The operand is a 32-bit IEEE floating point number.</summary>
		ShortR,
		/// <summary>The operand is an 8-bit integer containing the ordinal of a local variable or an argumenta.</summary>
		ShortVariable
	}

<#
	foreach (var field in typeof(OpCodes).GetFields()) {
		var opCode = (OpCode)field.GetValue(null);
		ushort index = (ushort)(((opCode.Value & 0x200) >> 1) | (opCode.Value & 0xff));
		operandTypes[index] = opCode.OperandType;
		operandNames[index] = opCode.Name;
	} #>

	static class ILOpCodeExtensions
	{
		// We use a byte array instead of an enum array because it can be initialized more efficiently
		static readonly byte[] operandTypes = { <#
			foreach (var operandType in operandTypes) {
				if ((byte)operandType == 255) {
					Write("255, ");
				} else {
					string operandTypeName = operandType.ToString().Replace("Inline", "").Replace("Var", "Variable");
					Write("(byte)OperandType." + operandTypeName + ", ");
				}
			}
		#> };

		static readonly string[] operandNames = { <#
			foreach (var operandName in operandNames) {
				Write("\"" + operandName + "\", ");
			}
		#> };

		public static OperandType GetOperandType(this ILOpCode opCode)
		{
			ushort index = (ushort)((((int)opCode & 0x200) >> 1) | ((int)opCode & 0xff));
			if (index >= operandTypes.Length)
				return (OperandType)255;
			return (OperandType)operandTypes[index];
		}

		public static string GetDisplayName(this ILOpCode opCode)
		{
			ushort index = (ushort)((((int)opCode & 0x200) >> 1) | ((int)opCode & 0xff));
			if (index >= operandNames.Length)
				return "";
			return operandNames[index];
		}

		public static bool IsDefined(this ILOpCode opCode)
		{
			return !string.IsNullOrEmpty(GetDisplayName(opCode));
		}

		public static readonly HashSet<string> ILKeywords = BuildKeywordList(
			"abstract", "algorithm", "alignment", "ansi", "any", "arglist",
			"array", "as", "assembly", "assert", "at", "auto", "autochar", "beforefieldinit",
			"blob", "blob_object", "bool", "brnull", "brnull.s", "brzero", "brzero.s", "bstr",
			"bytearray", "byvalstr", "callmostderived", "carray", "catch", "cdecl", "cf",
			"char", "cil", "class", "clsid", "const", "currency", "custom", "date", "decimal",
			"default", "demand", "deny", "endmac", "enum", "error", "explicit", "extends", "extern",
			"false", "famandassem", "family", "famorassem", "fastcall", "fault", "field", "filetime",
			"filter", "final", "finally", "fixed", "float", "float32", "float64", "forwardref",
			"fromunmanaged", "handler", "hidebysig", "hresult", "idispatch", "il", "illegal",
			"implements", "implicitcom", "implicitres", "import", "in", "inheritcheck", "init",
			"initonly", "instance", "int", "int16", "int32", "int64", "int8", "interface", "internalcall",
			"iunknown", "lasterr", "lcid", "linkcheck", "literal", "localloc", "lpstr", "lpstruct", "lptstr",
			"lpvoid", "lpwstr", "managed", "marshal", "method", "modopt", "modreq", "native", "nested",
			"newslot", "noappdomain", "noinlining", "nomachine", "nomangle", "nometadata", "noncasdemand",
			"noncasinheritance", "noncaslinkdemand", "noprocess", "not", "not_in_gc_heap", "notremotable",
			"notserialized", "null", "nullref", "object", "objectref", "opt", "optil", "out",
			"permitonly", "pinned", "pinvokeimpl", "prefix1", "prefix2", "prefix3", "prefix4", "prefix5", "prefix6",
			"prefix7", "prefixref", "prejitdeny", "prejitgrant", "preservesig", "private", "privatescope", "protected",
			"public", "record", "refany", "reqmin", "reqopt", "reqrefuse", "reqsecobj", "request", "retval",
			"rtspecialname", "runtime", "safearray", "sealed", "sequential", "serializable", "special", "specialname",
			"static", "stdcall", "storage", "stored_object", "stream", "streamed_object", "string", "struct",
			"synchronized", "syschar", "sysstring", "tbstr", "thiscall", "tls", "to", "true", "typedref",
			"unicode", "unmanaged", "unmanagedexp", "unsigned", "unused", "userdefined", "value", "valuetype",
			"vararg", "variant", "vector", "virtual", "void", "wchar", "winapi", "with", "wrapper",

			// These are not listed as keywords in spec, but ILAsm treats them as such
			"property", "type", "flags", "callconv", "strict"
		);

		static HashSet<string> BuildKeywordList(params string[] keywords)
		{
			HashSet<string> s = new HashSet<string>(keywords);
			foreach (var inst in operandNames) {
				if (string.IsNullOrEmpty(inst))
					continue;
				s.Add(inst);
			}
			return s;
		}
	}
}
